{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-60b41c619dd866f619c33824e322d47bc5ccb47c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/MerkleProof.sol": "project/contracts/MerkleProof.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/MerkleProof.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title MerkleProofX\n * @dev A decentralized contract for registering and verifying Merkle proofs (now optimized for kOS)\n */\ncontract MerkleProofX {\n    // Struct to store Merkle tree information\n    struct MerkleTreeInfo {\n        string description;\n        uint256 timestamp;\n        uint256 listSize;\n        address creator;\n        bool isActive;\n    }\n\n    // Platform fee configuration\n    uint256 public platformFee = 0.001 ether; // 0.001 ETH fee\n    address public platformTreasury;\n\n    // Trusted verifier for off-chain signatures (kOS service)\n    address public trustedVerifier;\n\n    // Track user's first tree status\n    mapping(address => bool) public isNewcomer;\n\n    // Mapping to store Merkle roots and their information\n    mapping(bytes32 => MerkleTreeInfo) public merkleTrees;\n    mapping(address => bool) public isKosVerified;\n\n    // Events\n    event MerkleTreeAdded(bytes32 indexed root, string description, uint256 listSize, address creator, uint256 feePaid);\n    event MerkleTreeRemoved(bytes32 indexed root, address remover);\n    event MerkleTreeUpdated(bytes32 indexed root, string newDescription, address updater);\n    event PlatformFeeUpdated(uint256 newFee);\n    event TreasuryUpdated(address newTreasury);\n    event FeeCollected(address user, uint256 amount);\n    event TrustedVerifierUpdated(address newVerifier);\n\n    constructor(address _treasury) {\n        require(_treasury != address(0), \"Invalid treasury address\");\n        platformTreasury = _treasury;\n        // Set deployer as newcomer\n        isNewcomer[msg.sender] = true;\n    }\n\n    /**\n     * @dev Set a user as a newcomer (only callable by treasury)\n     */\n    function setNewcomerStatus(address _user, bool _isNewcomer) external {\n        require(msg.sender == platformTreasury, \"Only treasury can set newcomer status\");\n        isNewcomer[_user] = _isNewcomer;\n    }\n\n    /**\n     * @dev Adds a new Merkle root to the contract\n     */\n    function addMerkleTree(bytes32 _root, string memory _description, uint256 _listSize) external payable {\n        require(_root != bytes32(0), \"Merkle root cannot be zero\");\n        require(!merkleTrees[_root].isActive, \"Tree already exists\");\n        require(_listSize > 0, \"List size must be greater than 0\");\n        require(bytes(_description).length > 0, \"Description cannot be empty\");\n\n        // Handle platform fee\n        if (isNewcomer[msg.sender]) {\n            // Newcomers can add first tree for free\n            isNewcomer[msg.sender] = false;\n        } else {\n            // Non-newcomers must pay fee\n            require(msg.value >= platformFee, \"Insufficient fee\");\n            (bool success, ) = platformTreasury.call{ value: msg.value }(\"\");\n            require(success, \"Fee transfer failed\");\n            emit FeeCollected(msg.sender, msg.value);\n        }\n\n        merkleTrees[_root] = MerkleTreeInfo({\n            description: _description,\n            timestamp: block.timestamp,\n            listSize: _listSize,\n            creator: msg.sender,\n            isActive: true\n        });\n\n        emit MerkleTreeAdded(_root, _description, _listSize, msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Updates platform fee (only callable by treasury)\n     */\n    function updatePlatformFee(uint256 _newFee) external {\n        require(msg.sender == platformTreasury, \"Only treasury can update fee\");\n        platformFee = _newFee;\n        emit PlatformFeeUpdated(_newFee);\n    }\n\n    /**\n     * @dev Updates treasury address (only callable by current treasury)\n     */\n    function updateTreasury(address _newTreasury) external {\n        require(msg.sender == platformTreasury, \"Only treasury can update address\");\n        require(_newTreasury != address(0), \"Invalid treasury address\");\n        platformTreasury = _newTreasury;\n        emit TreasuryUpdated(_newTreasury);\n    }\n\n    /**\n     * @dev Sets the trusted verifier address (only callable by treasury)\n     */\n    function setTrustedVerifier(address _verifier) external {\n        require(msg.sender == platformTreasury, \"Only treasury can set verifier\");\n        require(_verifier != address(0), \"Verifier cannot be zero address\");\n        trustedVerifier = _verifier;\n        emit TrustedVerifierUpdated(_verifier);\n    }\n\n    /**\n     * @dev Verifies a kOS signed proof for a claimer\n     */\n    function submitVerifiedProof(address _claimer, bytes memory _signature) external returns (bool) {\n        require(trustedVerifier != address(0), \"Trusted verifier not set\");\n\n        bytes32 messageHash = keccak256(abi.encodePacked(_claimer));\n        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\n\n        address recoveredSigner = recoverSigner(ethSignedMessageHash, _signature);\n        bool isValid = recoveredSigner == trustedVerifier;\n\n        if (isValid) {\n            isKosVerified[_claimer] = true;\n        }\n\n        return isValid;\n    }\n\n    /**\n     * @dev Removes a Merkle tree from the contract\n     */\n    function removeMerkleTree(bytes32 _root) external {\n        require(merkleTrees[_root].isActive, \"Tree does not exist\");\n        require(merkleTrees[_root].creator == msg.sender, \"Only creator can remove\");\n\n        merkleTrees[_root].isActive = false;\n        emit MerkleTreeRemoved(_root, msg.sender);\n    }\n\n    /**\n     * @dev Updates a Merkle tree's description\n     */\n    function updateMerkleTreeDescription(bytes32 _root, string memory _newDescription) external {\n        require(merkleTrees[_root].isActive, \"Tree does not exist\");\n        require(merkleTrees[_root].creator == msg.sender, \"Only creator can update\");\n        require(bytes(_newDescription).length > 0, \"Description cannot be empty\");\n\n        merkleTrees[_root].description = _newDescription;\n        emit MerkleTreeUpdated(_root, _newDescription, msg.sender);\n    }\n\n    /**\n     * @dev Gets information about a Merkle tree\n     */\n    function getMerkleTreeInfo(bytes32 _root) external view returns (MerkleTreeInfo memory) {\n        require(merkleTrees[_root].isActive, \"Tree does not exist\");\n        return merkleTrees[_root];\n    }\n\n    /**\n     * @dev Checks if a Merkle root exists in the contract\n     */\n    function isMerkleRootValid(bytes32 _root) external view returns (bool) {\n        return merkleTrees[_root].isActive;\n    }\n\n    /**\n     * @dev Gets the current platform fee\n     */\n    function getPlatformFee() external view returns (uint256) {\n        return platformFee;\n    }\n\n    /**\n     * @dev Checks if an address is a newcomer\n     */\n    function isUserNewcomer(address _user) external view returns (bool) {\n        return isNewcomer[_user];\n    }\n\n    /**\n     * @dev Helper to recover signer address from signature\n     */\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    /**\n     * @dev Helper to split a signature into r, s, v components\n     */\n    function splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"Invalid signature length\");\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n    }\n}\n"
      }
    }
  }
}